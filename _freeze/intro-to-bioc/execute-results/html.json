{
  "hash": "0da14d8ba96e5e7c06f0cccc7d8a6c32",
  "result": {
    "markdown": "# Introduction to Bioconductor\n\n## Learning objectives\n\n1.  Describe what is the Bioconductor and how it's different than CRAN\n2.  Describe the package types in Bioconductor\n3.  Recognize and work with core Bioconductor objects including `SummarizedExperiment`\n4.  Be able to perform a basic differential expression analysis with bulk RNA-seq\n5.  Introduce the core Bioconductor object called `SingleCellExperiment`.\n\n## A brief history of Bioconductor\n\nThe Bioconductor project was **started in the Fall of 2001**, as an initiative for the collaborative creation of extensible software for computational biology and bioinformatics.\n\nThe **goal of the project** is to develop tools for the statistical analysis and comprehension of large datasets and technological artifacts in rigorously and robustly designed experiments. Beyond statistical analyses, the interpretation of statistical results is supported by packages providing biological context, visualization, and reproducibility.\n\nOver the years, software packages contributed to the Bioconductor project have reflected the evolution and emergence of several high-throughput technologies, from microarrays to single-cell genomics, through **many variations of sequencing experiments** (e.g., RNA-seq, ChIP-seq, DNA-seq), analyses (e.g., sequence variation, copy number variation, single nucleotide polymorphisms), and data modalities (e.g., flow cytometry, proteomics, microscropy and image analysis).\n\nThe Bioconductor project culminates at an **annual conference in North America in the summer**, while regional conferences offer great opportunities for networking in Europe, Asia, and North America.\n\nThe project is **committed to promote a diverse and inclusive community**, including a [Code of Conduct](https://www.bioconductor.org/about/code-of-conduct/) enforced by a Code of Conduct committee.\n\n![Timeline of major Bioconductor milestones alongside technological advancements.](https://github.com/carpentries-incubator/bioc-project/raw/main/episodes/fig/bioc-timeline.svg)\n\n**Timeline of major Bioconductor milestones alongside technological advancements.** Above the timeline, the figure marks the first occurrence of major events. Within the timeline, the name of packages providing core infrastructure indicate the release date. Below the timeline, major technological advancements contextualise the evolution of the Bioconductor project over time.\n\n## A scientific project\n\n-   The original publication describes the aims and methods of the project at its inception is Gentleman et al. (2004).\n\n-   [Huber et al. (2015)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4509590) illustrates the progression of the project, including descriptions of core infrastructure and case studies, from the perspective of both users and developers.\n\n-   [Amezquita et al. (2020)](https://pubmed.ncbi.nlm.nih.gov/31792435) reviewed further developments of the project in the wake of single-cell genomics technologies.\n\nMany more publications and book chapters cite the Bioconductor project, with recent example listed on the [Bioconductor website](https://www.bioconductor.org/help/publications/).\n\nIn addition, there is a **core team** which is supported by an NIH grant, and developers who contribute to the open source Bioconductor packages.\n\n## A package repository\n\n## Overview and relationship to CRAN\n\nUndoubtedly, **software packages are the best-known aspect of the Bioconductor project**. Since its inception in 2001, the repository has grown over time to host thousands of packages.\n\nThe Bioconductor project has extended the preexisting CRAN repository -- much larger and general-purpose in scope -- to comprise R packages primarily catering for bioinformatics and computational biology analyses.\n\n## The Bioconductor release cycle\n\nThe Bioconductor project also extended the packaging infrastructure of the CRAN repository to better support the deployment and management of packages at the user level.\n\nIn particular, the **Bioconductor projects features a 6-month release cycle** (typically around April and October), which sees a snapshot of the current version of all packages in the Bioconductor repository earmarked for a specific version of R.\n\n**R itself is released on an annual basis** (typically around April), meaning that for each release of R, two compatible releases of Bioconductor packages are available.\n\n-   As such, **Bioconductor package developers are required to always use the version of R that will be associated with the next release of the Bioconductor** project.\n\n-   This means using the development version of R between October and April, and the release version of R between April and October.\n\nWhy? The strict Bioconductor release cycle **prevents users from installing temporally distant versions of packages** that were very likely never tested together.\n\nThis practice **reflects the development cycle of packages of both CRAN and Bioconductor**, where contemporaneous packages are regularly tested by automated systems to ensure that the latest software updates in package dependencies do not break downstream packages, or prompts those package maintainers to update their own software as a consequence.\n\nPrior to each Bioconductor release, packages that do not pass the requires suites of automated tests are deprecated and subsequently removed from the repository.\n\nThis **ensures that each Bioconductor release** provides a suite of packages that are mutually compatible, traceable, and guaranteed to function for the associated version of R.\n\n![Timeline of release dates for selected Bioconductor and R versions.](https://github.com/carpentries-incubator/bioc-project/raw/main/episodes/fig/bioc-release-cycle.svg)\n\n**Timeline of release dates for selected Bioconductor and R versions.** The upper section of the timeline indicates versions and approximate release dates for the R project. The lower section of the timeline indicates versions and release dates for the Bioconductor project. Source: [Bioconductor](https://bioconductor.org/about/release-announcements/).\n\n## Package types\n\nPackages are broadly divided in four major categories:\n\n1.  software\n2.  annotation data\n3.  experiment data\n4.  workflows\n\n**Software packages** themselves can be subdivided into packages that\n\n-   provide **infrastructure** (i.e., classes) to store and access data\n-   packages that provide **methodological tools** to process data stored in those data structures\n\nThis **separation of structure and analysis** is at the core of the Bioconductor project, encouraging developers of new methodological software packages to thoughtfully re-use existing data containers where possible, and **reducing the cognitive burden** imposed on users who can more easily experiment with alternative workflows without the need to learn and convert between different data structures.\n\n**Annotation data packages** provide self-contained databases of diverse genomic annotations (e.g., gene identifiers, biological pathways).\n\n-   Different collections of annotation packages can be found in the Bioconductor project.\n-   They are identifiable by their respective naming pattern, and the information that they contain.\n\nFor instance, the so-called `OrgDb` packages (e.g., the *[org.Hs.eg.db](https://bioconductor.org/packages/3.17/org.Hs.eg.db)* package) provide information mapping different types of gene identifiers and pathway databases; the so-called `EnsDb` (e.g., *[EnsDb.Hsapiens.v86](https://bioconductor.org/packages/3.17/EnsDb.Hsapiens.v86)*) packages encapsulate individual versions of the Ensembl annotations in Bioconductor packages; and the so-called `TxDb` packages (e.g., *[TxDb.Hsapiens.UCSC.hg38.knownGene](https://bioconductor.org/packages/3.17/TxDb.Hsapiens.UCSC.hg38.knownGene)*) encapsulate individual versions UCSC gene annotation tables.\n\n**Experiment data packages** provide self-contained datasets that are often used by software package developers to demonstrate the use of their package on well-known standard datasets in their **package vignettes**.\n\nFinally, **workflow packages** exclusively provide collections of vignettes that demonstrate the combined usage of several other packages as a coherent workflow, but do not provide any new source code or functionality themselves.\n\n## Online communication channels\n\n### Support site\n\nThe Bioconductor [support site](https://support.bioconductor.org/) provides a platform where users and developers can communicate freely (following the Bioconductor [Code of Conduct](https://www.bioconductor.org/about/code-of-conduct/)) to discuss issues on a range of subjects, ranging from packages to conceptual questions about best practices.\n\n### Slack workspace\n\nThe Bioconductor [Slack workspace](https://bioc-community.herokuapp.com/) is an open space that all community members are welcome to join (for free) and use for rapid interactions. Currently, the \"Pro\" pricing plan kindly supported by core funding provides:\n\n-   Unlimited message archive\n-   Unlimited apps\n-   Group video calls with screen sharing\n-   Work securely with other organizations using Slack Connect\n\nA wide range of channels have been created to discuss a range of subjects, and community members can freely join the discussion on those channels of create new ones to discuss new subjects.\n\nImportant announcements are posted on the `#general` channel.\n\n### Developer Mailing List\n\nThe [bioc-devel\\@r-project.org](mailto:bioc-devel@r-project.org){.email} mailing list is used for communication between package developers, and announcements from the Biocondutor core team.\n\n### A scientific and technical community\n\n-   [Scientific Advisory Board (SAB)](https://bioconductor.org/about/scientific-advisory-board/) Meet Annually, External and Internal leader in the field who act as project advisors. No Term limits.\n-   [Technical Advisory Board (TAB)](https://bioconductor.org/about/technical-advisory-board/). Meet monthly to consider technical aspects of core infastructure and scientific direction of the project. 15 members, 3 year term. Annual open-to-all elections to rotate members. Current officers are Vince Carey (chair), Levi Waldron (vice Chair) Charlotte Soneson (Secretary).\n-   [Community Advisory Board (CAB)](https://bioconductor.org/about/community-advisory-board/) Meet monthly to consider community outreach, events, education and training. 15 members, 3 year term. Annual open-to-all elections to rotate members. Current officers are Aedin Culhane (chair), Matt Ritchie (co Chair), Lori Kern (Secretary).\n-   [Code of Conduct committee](https://www.bioconductor.org/about/code-of-conduct/)\n\n## Getting started with Bioconductor\n\nBefore we get started, you need to know how to install Bioconductor packages. The most important details are:\n\n-   Bioconductor is a package repository, like CRAN\n-   All Bioconductor packages **must** be installed following the instructions here: <https://bioconductor.org/install>\n-   Bioconductor packages are linked in their versions, both to each other and to the version of R\n-   Bioconductor's installation function will look up your version of R and give you the appropriate versions of Bioconductor packages\n-   If you want the latest version of Bioconductor, you need to use the latest version of R.\n\nHow do you know if a package is a Bioconductor package?\n\nFor one thing, you can just **google the package name** and you will see either CRAN or Bioconductor as a first result (packages must be in one or the other, they are not allowed to be on both repositories).\n\nBut also, you can use Bioconductor's installation function to install any packages, even ones on CRAN.\n\nBy the way, you can install multiple packages at once by making a string vector: `BiocManager::install(c(\"foo\",\"bar\"))`\n\n### Working with Bioconductor objects\n\nBioconductor's infrastructure is **built up of object classes**.\n\nAn example of a class is **GRanges** (stands for \"genomic ranges\"), which is a way to specify a set of ranges in a particular genome, e.g. from basepair 101 to basepair 200 on chromosome 1 of the human genome (version 38).\n\nWhat is an object?\n\nWell **everything in R is an object**, but usually when we talk about Bioconductor objects, we mean data structures containing many attributes, so more complex than a vector or matrix.\n\nAnd the objects have specific **methods** that help you either access the information in the object, run analyses on the object, plot the object, etc.\n\nBioconductor also allows for **class hierarchy**, which means that you can define a class of object that inherits the structure and methods of a **superclass** on which it depends. This last point is mostly important for people who are developing new software for Bioconductor (maybe that's you!)\n\nWe will introduce the core Bioconductor objects here.\n\n### SummarizedExperiment (SE)\n\nFirst, we will discuss one of the most important classes of object, which is the *SummarizedExperiment*, or SE.\n\nSEs have the structure:\n\n-   a matrix of data, rows are genomic features, and columns are samples\n-   a table of data about the samples (columns)\n-   a table of data about the features (rows)\n\nA diagram of this 3-part structure can be found [here](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4509590/figure/F2/).\n\nIn SE, the 3 parts of the object are called 1) `assay`, 2) `colData` and 3) `rowData` or `rowRanges`.\n\n**Note**: There was a class of object that came before the SE, called the **ExpressionSet**, which was used primarily to store **microarray** data.\n\nHere, we will skip over the **ExpressionSet**, and just look at SEs.\n\nIt helps to start by making a small toy SE, to see how the pieces come together. (Often you won't make an SE manually, but it will be downloaded from an external source, or generated by a function that you call, e.g. the *[tximeta](https://bioconductor.org/packages/3.17/tximeta)* or some other data loading function.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(SummarizedExperiment)\ncol_data <- data.frame(sample=factor(1:6),\n                       condition=factor(c(\"A\",\"A\",\"B\",\"B\",\"C\",\"C\")),\n                       treated=factor(rep(0:1,3)))\ncol_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  sample condition treated\n1      1         A       0\n2      2         A       1\n3      3         B       0\n4      4         B       1\n5      5         C       0\n6      6         C       1\n```\n:::\n:::\n\n\nAn important aspect of SEs is that the rows can optionally correspond to particular set of **GRanges**\n\n-   e.g. a row of an SE could give the number of RNA-seq reads that can be assigned to a particular gene, and the row could also have metadata in the 3rd slot including, e.g. location of the gene in the genome.\n\nIn this case, we use the `rowRanges` slot to specify the information.\n\nIf we don't have ranges, we can just put a table on the \"side\" of the SE by specifying `rowData`.\n\nI will show in the example though how to provide `rowRanges`.\n\nLet's **use the first 10 genes in the Ensembl database** for human.\n\nThe following code loads a database, pulls out all the genes (as *GRanges*), removes extra \"non-standard\" chromosomes, and then subsets to the first 10 genes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(EnsDb.Hsapiens.v86)\ntxdb <- EnsDb.Hsapiens.v86\ng <- genes(txdb)\ng <- keepStandardChromosomes(g, pruning.mode=\"coarse\")\nrow_ranges <- g[1:10]\nrow_ranges\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGRanges object with 10 ranges and 6 metadata columns:\n                  seqnames       ranges strand |         gene_id    gene_name\n                     <Rle>    <IRanges>  <Rle> |     <character>  <character>\n  ENSG00000223972        1  11869-14409      + | ENSG00000223972      DDX11L1\n  ENSG00000227232        1  14404-29570      - | ENSG00000227232       WASH7P\n  ENSG00000278267        1  17369-17436      - | ENSG00000278267    MIR6859-1\n  ENSG00000243485        1  29554-31109      + | ENSG00000243485    MIR1302-2\n  ENSG00000237613        1  34554-36081      - | ENSG00000237613      FAM138A\n  ENSG00000268020        1  52473-53312      + | ENSG00000268020       OR4G4P\n  ENSG00000240361        1  62948-63887      + | ENSG00000240361      OR4G11P\n  ENSG00000186092        1  69091-70008      + | ENSG00000186092        OR4F5\n  ENSG00000238009        1 89295-133723      - | ENSG00000238009 RP11-34P13.7\n  ENSG00000239945        1  89551-91105      - | ENSG00000239945 RP11-34P13.8\n                            gene_biotype seq_coord_system       symbol\n                             <character>      <character>  <character>\n  ENSG00000223972 transcribed_unproces..       chromosome      DDX11L1\n  ENSG00000227232 unprocessed_pseudogene       chromosome       WASH7P\n  ENSG00000278267                  miRNA       chromosome    MIR6859-1\n  ENSG00000243485                lincRNA       chromosome    MIR1302-2\n  ENSG00000237613                lincRNA       chromosome      FAM138A\n  ENSG00000268020 unprocessed_pseudogene       chromosome       OR4G4P\n  ENSG00000240361 unprocessed_pseudogene       chromosome      OR4G11P\n  ENSG00000186092         protein_coding       chromosome        OR4F5\n  ENSG00000238009                lincRNA       chromosome RP11-34P13.7\n  ENSG00000239945                lincRNA       chromosome RP11-34P13.8\n                                        entrezid\n                                          <list>\n  ENSG00000223972 100287596,100287102,727856,...\n  ENSG00000227232                           <NA>\n  ENSG00000278267                      102466751\n  ENSG00000243485            105376912,100302278\n  ENSG00000237613           654835,645520,641702\n  ENSG00000268020                           <NA>\n  ENSG00000240361                           <NA>\n  ENSG00000186092                          79501\n  ENSG00000238009                           <NA>\n  ENSG00000239945                           <NA>\n  -------\n  seqinfo: 25 sequences (1 circular) from GRCh38 genome\n```\n:::\n:::\n\n\nWe will make up some simulated \"expression\" measurements, and then store these in the SE.\n\nI call `list` so I can name the matrix, otherwise it would not be named.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexprs <- matrix(rnorm(6 * 10), ncol=6, nrow=10)\nse <- SummarizedExperiment(assay = list(\"exprs\" = exprs),\n                           colData = col_data,\n                           rowRanges = row_ranges)\nse\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: RangedSummarizedExperiment \ndim: 10 6 \nmetadata(0):\nassays(1): exprs\nrownames(10): ENSG00000223972 ENSG00000227232 ... ENSG00000238009\n  ENSG00000239945\nrowData names(6): gene_id gene_name ... symbol entrezid\ncolnames: NULL\ncolData names(3): sample condition treated\n```\n:::\n:::\n\n\nWe see this object has one named matrix. The object could have multiple matrices (as long as these are the same shape).\n\nIn that case you could access the first with `assay` and in general by name, e.g. `assay(se, \"exprs\")` or equivalently `assays(se)[[\"exprs\"]]` .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nassayNames(se)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"exprs\"\n```\n:::\n:::\n\n\nFinally, if we wanted to add data onto the rows, for example, the score of a test on the matrix data, we use the metadata columns function, or `mcols`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcols(se)$score <- rnorm(10)\nmcols(se)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 10 rows and 7 columns\n                        gene_id    gene_name           gene_biotype\n                    <character>  <character>            <character>\nENSG00000223972 ENSG00000223972      DDX11L1 transcribed_unproces..\nENSG00000227232 ENSG00000227232       WASH7P unprocessed_pseudogene\nENSG00000278267 ENSG00000278267    MIR6859-1                  miRNA\nENSG00000243485 ENSG00000243485    MIR1302-2                lincRNA\nENSG00000237613 ENSG00000237613      FAM138A                lincRNA\nENSG00000268020 ENSG00000268020       OR4G4P unprocessed_pseudogene\nENSG00000240361 ENSG00000240361      OR4G11P unprocessed_pseudogene\nENSG00000186092 ENSG00000186092        OR4F5         protein_coding\nENSG00000238009 ENSG00000238009 RP11-34P13.7                lincRNA\nENSG00000239945 ENSG00000239945 RP11-34P13.8                lincRNA\n                seq_coord_system       symbol                       entrezid\n                     <character>  <character>                         <list>\nENSG00000223972       chromosome      DDX11L1 100287596,100287102,727856,...\nENSG00000227232       chromosome       WASH7P                             NA\nENSG00000278267       chromosome    MIR6859-1                      102466751\nENSG00000243485       chromosome    MIR1302-2            105376912,100302278\nENSG00000237613       chromosome      FAM138A           654835,645520,641702\nENSG00000268020       chromosome       OR4G4P                             NA\nENSG00000240361       chromosome      OR4G11P                             NA\nENSG00000186092       chromosome        OR4F5                          79501\nENSG00000238009       chromosome RP11-34P13.7                             NA\nENSG00000239945       chromosome RP11-34P13.8                             NA\n                    score\n                <numeric>\nENSG00000223972  0.380039\nENSG00000227232  0.376984\nENSG00000278267 -0.344180\nENSG00000243485  0.296353\nENSG00000237613 -0.365122\nENSG00000268020 -0.370744\nENSG00000240361 -0.482420\nENSG00000186092  0.506719\nENSG00000238009 -1.244942\nENSG00000239945 -0.711263\n```\n:::\n:::\n\n\nAdding data to the column metadata is even easier, we can just use `$`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nse$librarySize <- runif(6,1e6,2e6)\ncolData(se)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 6 rows and 4 columns\n    sample condition  treated librarySize\n  <factor>  <factor> <factor>   <numeric>\n1        1         A        0     1829084\n2        2         A        1     1154462\n3        3         B        0     1294416\n4        4         B        1     1181782\n5        5         C        0     1824189\n6        6         C        1     1548881\n```\n:::\n:::\n\n\n### Using the ranges of a SE\n\nHow does this additional functionality of the `rowRanges` facilitate faster data analysis?\n\nSuppose we are working with another data set besides `se` and we find a region of interest on chromsome 1.\n\nIf we want to pull out the expression data for that region, we just ask for the subset of `se` that overlaps.\n\nFirst, we **build the query region**, and then use the **GRanges** function `overlapsAny()` within single square brackets (like you would subset any matrix-like object):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquery <- GRanges(\"1\", IRanges(25000,40000))\nse_sub <- se[overlapsAny(se, query), ]\n```\n:::\n\n\nWe could have equivalently used the shorthand code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nse_sub <- se[se %over% query,]\n```\n:::\n\n\nWe get just three ranges, and three rows of the SE:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowRanges(se_sub)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGRanges object with 3 ranges and 7 metadata columns:\n                  seqnames      ranges strand |         gene_id   gene_name\n                     <Rle>   <IRanges>  <Rle> |     <character> <character>\n  ENSG00000227232        1 14404-29570      - | ENSG00000227232      WASH7P\n  ENSG00000243485        1 29554-31109      + | ENSG00000243485   MIR1302-2\n  ENSG00000237613        1 34554-36081      - | ENSG00000237613     FAM138A\n                            gene_biotype seq_coord_system      symbol\n                             <character>      <character> <character>\n  ENSG00000227232 unprocessed_pseudogene       chromosome      WASH7P\n  ENSG00000243485                lincRNA       chromosome   MIR1302-2\n  ENSG00000237613                lincRNA       chromosome     FAM138A\n                              entrezid     score\n                                <list> <numeric>\n  ENSG00000227232                 <NA>  0.376984\n  ENSG00000243485  105376912,100302278  0.296353\n  ENSG00000237613 654835,645520,641702 -0.365122\n  -------\n  seqinfo: 25 sequences (1 circular) from GRCh38 genome\n```\n:::\n\n```{.r .cell-code}\nassay(se_sub)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                       [,1]       [,2]       [,3]       [,4]       [,5]\nENSG00000227232  0.05671462  0.8815780 -0.4166315 -0.4867187 -0.2596684\nENSG00000243485  0.13377727  0.3789532 -1.4283912  0.6204320  0.1966699\nENSG00000237613 -0.38430274 -0.5094666 -1.3842924  0.1265138 -1.1174225\n                      [,6]\nENSG00000227232  0.6200481\nENSG00000243485 -0.9938131\nENSG00000237613 -1.3297476\n```\n:::\n:::\n\n\nAnother useful property is that we know metadata about the chromosomes, and the version of the genome.\n\n-   **Note**: If you were not yet aware, the basepair position of a given feature, say gene *XYZ*, will change between versions of the genome, as sequences are added or rearranged.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseqinfo(se)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSeqinfo object with 25 sequences (1 circular) from GRCh38 genome:\n  seqnames seqlengths isCircular genome\n  1         248956422      FALSE GRCh38\n  10        133797422      FALSE GRCh38\n  11        135086622      FALSE GRCh38\n  12        133275309      FALSE GRCh38\n  13        114364328      FALSE GRCh38\n  ...             ...        ...    ...\n  8         145138636      FALSE GRCh38\n  9         138394717      FALSE GRCh38\n  MT            16569       TRUE GRCh38\n  X         156040895      FALSE GRCh38\n  Y          57227415      FALSE GRCh38\n```\n:::\n:::\n\n\n### Downloading SE data\n\nLet's download a SE object from [recount2](https://jhubiostatistics.shinyapps.io/recount/), which performs a basic summarization of public data sets with gene expression data.\n\nThis **dataset contains RNA-seq samples from human airway epithelial cell cultures**.\n\nThe paper is [here](https://www.ncbi.nlm.nih.gov/pubmed/25706956). The structure of the experiment was that, cell cultures from 6 asthmatic and 6 non-asthmatics donors were treated with viral infection or left untreated (controls).\n\nSo we have 2 samples (control or treated) for each of the 12 donors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(here)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nhere() starts at /Users/stephaniehicks/Documents/github/teaching/cshlcg2023\n```\n:::\n\n```{.r .cell-code}\n# tests if a directory named \"data\" exists locally\nif(!dir.exists(here(\"data\"))) { dir.create(here(\"data\")) }\n\nfile <- \"asthma.rda\"\nif (!file.exists(here(\"data\", file))){\n  url <- \"http://duffel.rail.bio/recount/SRP046226/rse_gene.Rdata\"\n  download.file(url, here(\"data\", file))\n}\nload(here(\"data\", file))\n```\n:::\n\n\nWe use a custom function to produce a matrix which a count of RNA fragments for each gene (rows) and each sample (columns).\n\n(Recount project calls these objects `rse` for **RangedSummarizedExperiment**, meaning it has `rowRanges` information.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_scale_counts <- function(rse_gene, round=TRUE) {\n  cts <- assays(rse_gene)$counts\n  # mapped_read_count includes the count for both reads of a pair\n  paired <- ifelse(colData(rse_gene)$paired_end, 2, 1)\n  x <- (colData(rse_gene)$mapped_read_count / paired) / colSums(cts)\n  assays(rse_gene)$counts <- t(t(assays(rse_gene)$counts) * x)\n  if (round) {\n    assays(rse_gene)$counts <- round(assays(rse_gene)$counts)\n  }\n  rse_gene\n}\n\nrse <- my_scale_counts(rse_gene)\n```\n:::\n\n\nWe can take a peek at the column data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolData(rse)[,1:6]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 24 rows and 6 columns\n               project      sample  experiment         run\n           <character> <character> <character> <character>\nSRR1565926   SRP046226   SRS694613   SRX692912  SRR1565926\nSRR1565927   SRP046226   SRS694614   SRX692913  SRR1565927\nSRR1565928   SRP046226   SRS694615   SRX692914  SRR1565928\nSRR1565929   SRP046226   SRS694616   SRX692915  SRR1565929\nSRR1565930   SRP046226   SRS694617   SRX692916  SRR1565930\n...                ...         ...         ...         ...\nSRR1565945   SRP046226   SRS694632   SRX692931  SRR1565945\nSRR1565946   SRP046226   SRS694633   SRX692932  SRR1565946\nSRR1565947   SRP046226   SRS694634   SRX692933  SRR1565947\nSRR1565948   SRP046226   SRS694635   SRX692934  SRR1565948\nSRR1565949   SRP046226   SRS694636   SRX692935  SRR1565949\n           read_count_as_reported_by_sra reads_downloaded\n                               <integer>        <integer>\nSRR1565926                      12866750         12866750\nSRR1565927                      12797108         12797108\nSRR1565928                      13319016         13319016\nSRR1565929                      13725752         13725752\nSRR1565930                      10882416         10882416\n...                                  ...              ...\nSRR1565945                      13791854         13791854\nSRR1565946                      13480842         13480842\nSRR1565947                      13166594         13166594\nSRR1565948                      13320398         13320398\nSRR1565949                      13002276         13002276\n```\n:::\n:::\n\n\nThe information we are interested in is contained in the `characteristics` column (which is a character list).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(rse$characteristics)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"CompressedCharacterList\"\nattr(,\"package\")\n[1] \"IRanges\"\n```\n:::\n\n```{.r .cell-code}\nrse$characteristics[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacterList of length 3\n[[1]] cell type: Isolated from human trachea-bronchial tissues ...\n[[2]] cell type: Isolated from human trachea-bronchial tissues ...\n[[3]] cell type: Isolated from human trachea-bronchial tissues ...\n```\n:::\n\n```{.r .cell-code}\nrse$characteristics[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"cell type: Isolated from human trachea-bronchial tissues\"\n[2] \"passages: 2\"                                             \n[3] \"disease state: asthmatic\"                                \n[4] \"treatment: HRV16\"                                        \n```\n:::\n:::\n\n\nWe can pull out the 3 and 4 element using the `sapply` function and the square bracket function.\n\nI know this syntax looks a little funny, but it's really just saying, use the single square bracket, pull out the third element (or fourth element).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrse$condition <- sapply(rse$characteristics, `[`, 3)\nrse$treatment <- sapply(rse$characteristics, `[`, 4)\ntable(rse$condition, rse$treatment)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                              \n                               treatment: HRV16 treatment: Vehicle\n  disease state: asthmatic                    6                  6\n  disease state: non-asthmatic                6                  6\n```\n:::\n:::\n\n\nLet's see what the `rowRanges` of this experiment look like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowRanges(rse)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGRanges object with 58037 ranges and 3 metadata columns:\n                     seqnames              ranges strand |            gene_id\n                        <Rle>           <IRanges>  <Rle> |        <character>\n  ENSG00000000003.14     chrX 100627109-100639991      - | ENSG00000000003.14\n   ENSG00000000005.5     chrX 100584802-100599885      + |  ENSG00000000005.5\n  ENSG00000000419.12    chr20   50934867-50958555      - | ENSG00000000419.12\n  ENSG00000000457.13     chr1 169849631-169894267      - | ENSG00000000457.13\n  ENSG00000000460.16     chr1 169662007-169854080      + | ENSG00000000460.16\n                 ...      ...                 ...    ... .                ...\n   ENSG00000283695.1    chr19   52865369-52865429      - |  ENSG00000283695.1\n   ENSG00000283696.1     chr1 161399409-161422424      + |  ENSG00000283696.1\n   ENSG00000283697.1     chrX 149548210-149549852      - |  ENSG00000283697.1\n   ENSG00000283698.1     chr2 112439312-112469687      - |  ENSG00000283698.1\n   ENSG00000283699.1    chr10   12653138-12653197      - |  ENSG00000283699.1\n                     bp_length          symbol\n                     <integer> <CharacterList>\n  ENSG00000000003.14      4535          TSPAN6\n   ENSG00000000005.5      1610            TNMD\n  ENSG00000000419.12      1207            DPM1\n  ENSG00000000457.13      6883           SCYL3\n  ENSG00000000460.16      5967        C1orf112\n                 ...       ...             ...\n   ENSG00000283695.1        61            <NA>\n   ENSG00000283696.1       997            <NA>\n   ENSG00000283697.1      1184    LOC101928917\n   ENSG00000283698.1       940            <NA>\n   ENSG00000283699.1        60         MIR4481\n  -------\n  seqinfo: 25 sequences (1 circular) from an unspecified genome; no seqlengths\n```\n:::\n\n```{.r .cell-code}\nseqinfo(rse)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSeqinfo object with 25 sequences (1 circular) from an unspecified genome; no seqlengths:\n  seqnames seqlengths isCircular genome\n  chr1           <NA>       <NA>   <NA>\n  chr2           <NA>       <NA>   <NA>\n  chr3           <NA>       <NA>   <NA>\n  chr4           <NA>       <NA>   <NA>\n  chr5           <NA>       <NA>   <NA>\n  ...             ...        ...    ...\n  chr21          <NA>       <NA>   <NA>\n  chr22          <NA>       <NA>   <NA>\n  chrX           <NA>       <NA>   <NA>\n  chrY           <NA>       <NA>   <NA>\n  chrM           <NA>       TRUE   <NA>\n```\n:::\n:::\n\n\nThe `rowRanges` here were determined by the quantification method that the *recount2* authors used.\n\nWe don't know what the genome is from the `seqinfo`, but we could look this up from the project website.\n\nThe following code I use to clean up the condition and treatment variables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(magrittr)\nrse$condition %<>% (function(x) {\n  factor(sub(\"-\",\".\", sub(\"disease state: (.*)\",\"\\\\1\",x) ))\n  })\nrse$treatment %<>% (function(x) factor(sub(\"treatment: (.*)\",\"\\\\1\",x)))\n```\n:::\n\n\nNow we have:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(rse$condition, rse$treatment)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               \n                HRV16 Vehicle\n  asthmatic         6       6\n  non.asthmatic     6       6\n```\n:::\n:::\n\n\n### Visualizing count matrix data in a SE\n\nHere we just use a transformation so that we can compute meaningful distances on count data (without a larger discussion on normalization).\n\nWe build a **DESeqDataSet** and then specify the experimental design using a `~` and the variables that we expect to produce differences in the counts. (These variables are used to assess how much technical variability is in the data, but not used in the transformation function itself.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DESeq2)\ndds <- DESeqDataSet(rse, ~condition + treatment)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nconverting counts to integer mode\n```\n:::\n:::\n\n\nWe use this function, which implements a **variance stabilizing transformation**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvsd <- vst(dds)\n```\n:::\n\n\nWe calculate the variance across all samples (on the transformed data):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(matrixStats)\nrv <- rowVars(assay(vsd))\no <- order(rv, decreasing=TRUE)[1:100]\n```\n:::\n\n\nFinally, before plotting a heatmap, we **extract the covariates** that we want to annotated the top of the plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanno_col <- as.data.frame(colData(vsd)[,c(\"condition\",\"treatment\")])\nanno_col\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               condition treatment\nSRR1565926     asthmatic     HRV16\nSRR1565927     asthmatic     HRV16\nSRR1565928     asthmatic     HRV16\nSRR1565929     asthmatic     HRV16\nSRR1565930     asthmatic     HRV16\nSRR1565931     asthmatic     HRV16\nSRR1565932     asthmatic   Vehicle\nSRR1565933     asthmatic   Vehicle\nSRR1565934     asthmatic   Vehicle\nSRR1565935     asthmatic   Vehicle\nSRR1565936     asthmatic   Vehicle\nSRR1565937     asthmatic   Vehicle\nSRR1565938 non.asthmatic     HRV16\nSRR1565939 non.asthmatic     HRV16\nSRR1565940 non.asthmatic     HRV16\nSRR1565941 non.asthmatic     HRV16\nSRR1565942 non.asthmatic     HRV16\nSRR1565943 non.asthmatic     HRV16\nSRR1565944 non.asthmatic   Vehicle\nSRR1565945 non.asthmatic   Vehicle\nSRR1565946 non.asthmatic   Vehicle\nSRR1565947 non.asthmatic   Vehicle\nSRR1565948 non.asthmatic   Vehicle\nSRR1565949 non.asthmatic   Vehicle\n```\n:::\n:::\n\n\nThis code pull out the top of the transformed data by variance, and adds an annotation to the top of the plot.\n\nBy default the rows and columns will be clustered by Euclidean distance. See `?pheatmap` for more details on this function (it's a very detailed manual page).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pheatmap)\npheatmap(assay(vsd)[o,],\n         annotation_col=anno_col,\n         show_rownames=FALSE, \n         show_colnames=FALSE)\n```\n\n::: {.cell-output-display}\n![](intro-to-bioc_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\nWe can also easily make a PCA plot with dedicated functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotPCA(vsd, intgroup=\"treatment\")\n```\n\n::: {.cell-output-display}\n![](intro-to-bioc_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n## SingleCellExperiment\n\nAn example of a class that extends the SE is **SingleCellExperiment**. This is a special object type for looking at single cell data.\n\nFor more details, there is a free online book \"Orchestrating Single Cell Analysis With Bioconductor\" produced by a group within the Bioconductor Project, with lots of example analyses: [OSCA](http://bioconductor.org/books/3.15/OSCA.basic/).\n\nHere we show a quick example of how this object extends the SE.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(SingleCellExperiment)\nsce <- as(rse, \"SingleCellExperiment\")\nsce\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: SingleCellExperiment \ndim: 58037 24 \nmetadata(0):\nassays(1): counts\nrownames(58037): ENSG00000000003.14 ENSG00000000005.5 ...\n  ENSG00000283698.1 ENSG00000283699.1\nrowData names(3): gene_id bp_length symbol\ncolnames(24): SRR1565926 SRR1565927 ... SRR1565948 SRR1565949\ncolData names(23): project sample ... condition treatment\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\n```\n:::\n:::\n\n\nThere are special functions dedicated to scaling the samples (we will discuss this technical aspect soon):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(scran)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: scuttle\n```\n:::\n\n```{.r .cell-code}\nsce <- computeSumFactors(sce)\nsizeFactors(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.7672143 0.8205514 0.8686567 0.9479224 0.6484723 0.9815079 1.0797070\n [8] 1.0569889 1.4377886 0.9465292 1.4759422 1.2630195 0.8889808 1.0524670\n[15] 0.9677885 0.8086102 0.8806503 0.8999780 0.9505805 1.0430322 1.2527967\n[22] 0.9908707 0.5208294 1.4491155\n```\n:::\n:::\n\n\nSimilarly, dedicated functions for transformations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce <- logNormCounts(sce)\nassayNames(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"counts\"    \"logcounts\"\n```\n:::\n:::\n\n\nAnd dedicated functions and new slots for reduced dimensions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\nsce <- fixedPCA(sce, rank=5, subset.row=NULL)\nreducedDimNames(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"PCA\"\n```\n:::\n:::\n\n\nWe can manually get at the PCs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npca <- reducedDim(sce, \"PCA\")\nplot(pca[,1:2])\n```\n\n::: {.cell-output-display}\n![](intro-to-bioc_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\nBut we can more easily use dedicated visualization functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(scater)\nplotReducedDim(sce, \"PCA\", colour_by=\"treatment\")\n```\n\n::: {.cell-output-display}\n![](intro-to-bioc_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n\n## Session Info\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Sonoma 14.1.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: America/New_York\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] scater_1.28.0               ggplot2_3.4.4              \n [3] scran_1.28.2                scuttle_1.9.4              \n [5] SingleCellExperiment_1.22.0 pheatmap_1.0.12            \n [7] DESeq2_1.40.2               magrittr_2.0.3             \n [9] here_1.0.1                  EnsDb.Hsapiens.v86_2.99.0  \n[11] ensembldb_2.24.1            AnnotationFilter_1.24.0    \n[13] GenomicFeatures_1.52.2      AnnotationDbi_1.62.2       \n[15] SummarizedExperiment_1.30.2 Biobase_2.60.0             \n[17] GenomicRanges_1.52.1        GenomeInfoDb_1.36.4        \n[19] IRanges_2.34.1              S4Vectors_0.38.2           \n[21] BiocGenerics_0.46.0         MatrixGenerics_1.12.3      \n[23] matrixStats_1.0.0          \n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3        rstudioapi_0.15.0        \n  [3] jsonlite_1.8.7            ggbeeswarm_0.7.2         \n  [5] farver_2.1.1              rmarkdown_2.25           \n  [7] BiocIO_1.10.0             zlibbioc_1.46.0          \n  [9] vctrs_0.6.4               memoise_2.0.1            \n [11] Rsamtools_2.16.0          DelayedMatrixStats_1.22.6\n [13] RCurl_1.98-1.12           htmltools_0.5.6.1        \n [15] S4Arrays_1.0.6            progress_1.2.2           \n [17] curl_5.1.0                BiocNeighbors_1.18.0     \n [19] htmlwidgets_1.6.2         cachem_1.0.8             \n [21] GenomicAlignments_1.36.0  igraph_1.5.1             \n [23] lifecycle_1.0.4           pkgconfig_2.0.3          \n [25] rsvd_1.0.5                Matrix_1.6-1.1           \n [27] R6_2.5.1                  fastmap_1.1.1            \n [29] GenomeInfoDbData_1.2.10   digest_0.6.33            \n [31] colorspace_2.1-0          rprojroot_2.0.3          \n [33] dqrng_0.3.1               irlba_2.3.5.1            \n [35] RSQLite_2.3.1             beachmat_2.16.0          \n [37] filelock_1.0.2            labeling_0.4.3           \n [39] fansi_1.0.5               httr_1.4.7               \n [41] abind_1.4-5               compiler_4.3.1           \n [43] bit64_4.0.5               withr_2.5.2              \n [45] BiocParallel_1.34.2       viridis_0.6.4            \n [47] DBI_1.1.3                 biomaRt_2.56.1           \n [49] rappdirs_0.3.3            DelayedArray_0.26.7      \n [51] rjson_0.2.21              bluster_1.10.0           \n [53] tools_4.3.1               vipor_0.4.5              \n [55] beeswarm_0.4.0            glue_1.6.2               \n [57] restfulr_0.0.15           grid_4.3.1               \n [59] cluster_2.1.4             generics_0.1.3           \n [61] gtable_0.3.4              hms_1.1.3                \n [63] BiocSingular_1.16.0       ScaledMatrix_1.8.1       \n [65] metapod_1.7.0             xml2_1.3.5               \n [67] utf8_1.2.4                XVector_0.40.0           \n [69] ggrepel_0.9.4             pillar_1.9.0             \n [71] stringr_1.5.1             limma_3.56.2             \n [73] dplyr_1.1.4               BiocFileCache_2.8.0      \n [75] lattice_0.22-5            rtracklayer_1.60.1       \n [77] bit_4.0.5                 tidyselect_1.2.0         \n [79] locfit_1.5-9.8            Biostrings_2.68.1        \n [81] knitr_1.44                gridExtra_2.3            \n [83] ProtGenerics_1.32.0       edgeR_3.42.4             \n [85] xfun_0.40                 statmod_1.5.0            \n [87] stringi_1.8.2             lazyeval_0.2.2           \n [89] yaml_2.3.7                evaluate_0.22            \n [91] codetools_0.2-19          tibble_3.2.1             \n [93] BiocManager_1.30.22       cli_3.6.1                \n [95] munsell_0.5.0             Rcpp_1.0.11              \n [97] dbplyr_2.3.4              png_0.1-8                \n [99] XML_3.99-0.15             parallel_4.3.1           \n[101] blob_1.2.4                prettyunits_1.2.0        \n[103] sparseMatrixStats_1.12.2  bitops_1.0-7             \n[105] viridisLite_0.4.2         scales_1.3.0             \n[107] crayon_1.5.2              BiocStyle_2.28.1         \n[109] rlang_1.1.2               KEGGREST_1.40.1          \n```\n:::\n:::\n",
    "supporting": [
      "intro-to-bioc_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}