{
  "hash": "104ee027ed55303e4a129ebfb69d4274",
  "result": {
    "markdown": "# Overview of single-cell analysis in R/Bioconductor\n\n\n\n\n\n## Part 1\n\n### Learning objectives\n\n1.  Understand how count matrices are created from single-cell experimental platforms and protocols\n2.  Recognize which basic principles and concepts were transferred from bulk to single-cell data analyses\n3.  Understand the key differences between bulk and single-cell data\n4.  Define what is a \"Unique Molecular Identifier\"\n5.  Define multiplexing (and demultiplexing)\n6.  Overview of basics in single-cell data analyses including quality control, normalization, feature selection, dimensionality reduction, and clustering\n\n### Materials\n\nWe will go through the slides available here:\n\n-   https://docs.google.com/presentation/d/1XHfN-5NCXtu1P4reotrckGplPXJBTlQraFpd8ViPf1g/edit?usp=sharing\n\n## Part 2\n\n### Learning objectives\n\n1.  Be able to create a single-cell count matrix and read it into R\n2.  Recognize and define the `SingleCellExperiment` S4 class in R/Bioconductor to store single-cell data\n\n### Overview\n\nNGS data from scRNA-seq experiments must be converted into a matrix of expression values.\n\nThis is **usually a count matrix** containing the number of reads (or UMIs) mapped to each gene (row) in each cell (column). Once this quantification is complete, we can proceed with our downstream statistical analyses in R.\n\nConstructing a count matrix from raw scRNA-seq data requires some thought as the term \"single-cell RNA-seq\" encompasses a variety of different experimental protocols. This includes\n\n-   **droplet-based protocols** like 10X Genomics, inDrop and Drop-seq\n-   **plate-based protocols** with UMIs like CEL-seq(2) and MARS-seq\n-   **plate-based protocols** with reads (mostly Smart-seq2)\n-   others like sciRNA-seq, etc\n\nEach approach requires a different processing pipeline to deal with cell demultiplexing and UMI deduplication (if applicable). Here, we will briefly describe some of the methods used to generate a count matrix and read it into R.\n\n### Creating a count matrix\n\nAs mentioned above, the exact procedure for quantifying expression depends on the technology involved:\n\n-   For **10X Genomics data**, the `Cellranger` software suite (Zheng et al. 2017) provides a custom pipeline to obtain a count matrix. This uses STAR to align reads to the reference genome and then counts the number of unique UMIs mapped to each gene.\n-   Alternatively, pseudo-alignment methods such as [`alevin`](https://doi.org/10.1186/s13059-019-1670-y) (Srivastava et al. 2019) can be used to obtain a count matrix from the same data. This avoids the need for explicit alignment, which reduces the compute time and memory usage.\n-   For other **highly multiplexed protocols**, the [`scPipe`](http://bioconductor.org/packages/scPipe/) package provides a more general pipeline for processing scRNA-seq data. This uses the Rsubread aligner to align reads and then counts reads or UMIs per gene.\n-   For **CEL-seq or CEL-seq2 data**, the `scruff` package provides a dedicated pipeline for quantification.\n-   For **read-based protocols**, we can generally re-use the same pipelines for processing bulk RNA-seq data (e.g. Subread, RSEM, salmon)\n-   For **any data involving spike-in transcripts**, the spike-in sequences should be included as part of the reference genome during alignment and quantification.\n\nIn all cases, the **identity of the genes** in the count matrix should be **defined with standard identifiers from Ensembl or Entrez**. These provide an unambiguous mapping between each row of the matrix and the corresponding gene.\n\nIn contrast, **a single gene symbol** may be used by multiple loci, or the mapping between symbols and genes **may change over time**, e.g., if the gene is renamed.\n\nThis makes it difficult to re-use the count matrix as we cannot be confident in the meaning of the symbols.\n\n(Of course, **identifiers can be easily converted to gene symbols** later on in the analysis. This is the recommended approach as it allows us to document how the conversion was performed and to backtrack to the stable identifiers if the symbols are ambiguous.)\n\n### `SingleCellExperiment` Class\n\nOne of the **main strengths** of the Bioconductor project lies in the use of **a common data infrastructure** that powers interoperability across packages.\n\nUsers should be able to analyze their data using functions from different Bioconductor packages without the need to convert between formats.\n\nTo this end, the `SingleCellExperiment` class (from the `SingleCellExperiment` package) serves as the common currency for data exchange across 70+ single-cell-related Bioconductor packages.\n\nThis class implements a data structure that stores all aspects of our single-cell data - gene-by-cell expression data, per-cell metadata and per-gene annotation - and manipulate them in a synchronized manner.\n\n\n::: {.cell layout-align=\"center\" show='true' fig.caption='Overview of the structure of the `SingleCellExperiment` class. Each row of the assays corresponds to a row of the `rowData` (pink shading), while each column of the assays corresponds to a column of the `colData` and `reducedDims` (yellow shading).'}\n::: {.cell-output-display}\n![](figures/SingleCellExperiment.png){fig-align='center' width=780px}\n:::\n:::\n\n\n\\[Amezquita et al. 2019 (https://doi.org/10.1101/590562)\\]\n\n-   Each piece of (meta)data in the `SingleCellExperiment` is **represented by a separate \"slot\"**.\n\n(This terminology comes from the S4 class system, but that's not important right now).\n\nIf we imagine the `SingleCellExperiment` object to be a cargo ship, the **slots can be thought of as individual cargo boxes with different contents**, e.g., certain slots expect numeric matrices whereas others may expect data frames.\n\nIf you want to know more about the available slots, their expected formats, and how we can interact with them, check out this [chapter](https://bioconductor.org/books/3.15/OSCA.intro/the-singlecellexperiment-class.html).\n\n::: callout-note\n### `SingleCellExperiment` Example\n\nLet's show you what a `SingleCellExperiment` (or `sce` for short) looks like.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsce\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: SingleCellExperiment \ndim: 20006 3005 \nmetadata(0):\nassays(1): counts\nrownames(20006): Tspan12 Tshz1 ... mt-Rnr1 mt-Nd4l\nrowData names(1): featureType\ncolnames(3005): 1772071015_C02 1772071017_G12 ... 1772066098_A12\n  1772058148_F03\ncolData names(10): tissue group # ... level1class level2class\nreducedDimNames(0):\nmainExpName: endogenous\naltExpNames(2): ERCC repeat\n```\n:::\n:::\n\n\nThis `SingleCellExperiment` object has 20006 genes and 3005 cells.\n\nWe can pull out the counts matrix with the `counts()` function and the corresponding `rowData()` and `colData()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounts(sce)[1:5, 1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         1772071015_C02 1772071017_G12 1772071017_A05 1772071014_B06\nTspan12               0              0              0              3\nTshz1                 3              1              0              2\nFnbp1l                3              1              6              4\nAdamts15              0              0              0              0\nCldn12                1              1              1              0\n         1772067065_H06\nTspan12               0\nTshz1                 2\nFnbp1l                1\nAdamts15              0\nCldn12                0\n```\n:::\n\n```{.r .cell-code}\nrowData(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 20006 rows and 1 column\n         featureType\n         <character>\nTspan12   endogenous\nTshz1     endogenous\nFnbp1l    endogenous\nAdamts15  endogenous\nCldn12    endogenous\n...              ...\nmt-Co2          mito\nmt-Co1          mito\nmt-Rnr2         mito\nmt-Rnr1         mito\nmt-Nd4l         mito\n```\n:::\n\n```{.r .cell-code}\ncolData(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 3005 rows and 10 columns\n                       tissue   group # total mRNA mol      well       sex\n                  <character> <numeric>      <numeric> <numeric> <numeric>\n1772071015_C02       sscortex         1           1221         3         3\n1772071017_G12       sscortex         1           1231        95         1\n1772071017_A05       sscortex         1           1652        27         1\n1772071014_B06       sscortex         1           1696        37         3\n1772067065_H06       sscortex         1           1219        43         3\n...                       ...       ...            ...       ...       ...\n1772067059_B04 ca1hippocampus         9           1997        19         1\n1772066097_D04 ca1hippocampus         9           1415        21         1\n1772063068_D01       sscortex         9           1876        34         3\n1772066098_A12 ca1hippocampus         9           1546        88         1\n1772058148_F03       sscortex         9           1970        15         3\n                     age  diameter        cell_id       level1class level2class\n               <numeric> <numeric>    <character>       <character> <character>\n1772071015_C02         2         1 1772071015_C02      interneurons       Int10\n1772071017_G12         1       353 1772071017_G12      interneurons       Int10\n1772071017_A05         1        13 1772071017_A05      interneurons        Int6\n1772071014_B06         2        19 1772071014_B06      interneurons       Int10\n1772067065_H06         6        12 1772067065_H06      interneurons        Int9\n...                  ...       ...            ...               ...         ...\n1772067059_B04         4       382 1772067059_B04 endothelial-mural       Peric\n1772066097_D04         7        12 1772066097_D04 endothelial-mural        Vsmc\n1772063068_D01         7       268 1772063068_D01 endothelial-mural        Vsmc\n1772066098_A12         7       324 1772066098_A12 endothelial-mural        Vsmc\n1772058148_F03         7         6 1772058148_F03 endothelial-mural        Vsmc\n```\n:::\n:::\n\n:::\n\n## Part 3\n\n### Learning objectives\n\n1.  Be able to describe a standard workflow for analyzing single-cell data\n2.  Be able to run code for a standard workflow starting from loading a `SingleCellExperiment` in R and identifying clusters.\n\n### Overview\n\nHere, we provide an overview of the framework of a typical scRNA-seq analysis workflow:\n\n\n::: {.cell layout-align=\"center\" show='true' fig.caption='Schematic of a typical scRNA-seq analysis workflow. Each stage (separated by dashed lines) consists of a number of specific steps, many of which operate on and modify a SingleCellExperiment instance.'}\n::: {.cell-output-display}\n![](figures/workflow.png){fig-align='center' width=780px}\n:::\n:::\n\n\nIn the simplest case, the workflow has the following form:\n\n1.  We compute **quality control metrics** to remove low-quality cells that would interfere with downstream analyses. These cells may have been damaged during processing or may not have been fully captured by the sequencing protocol. Common metrics includes the total counts per cell, the proportion of spike-in or mitochondrial reads and the number of detected features.\n2.  We convert the counts into **normalized expression values** to eliminate cell-specific biases (e.g., in capture efficiency). This allows us to perform explicit comparisons across cells in downstream steps like clustering. We also apply a transformation, typically log, to adjust for the mean-variance relationship.\n3.  We perform **feature selection to pick a subset of interesting features** for downstream analysis. This is done by modelling the variance across cells for each gene and retaining genes that are highly variable. The aim is to reduce computational overhead and noise from uninteresting genes.\n4.  We apply **dimensionality reduction to compact the data** and further reduce noise. Principal components analysis is typically used to obtain an initial low-rank representation for more computational work, followed by more aggressive methods like $t$-stochastic neighbor embedding for visualization purposes.\n5.  We **cluster cells into groups** according to similarities in their (normalized) expression profiles. This aims to obtain groupings that serve as empirical proxies for distinct biological states. We typically interpret these groupings by identifying differentially expressed marker genes between clusters.\n\n### Quick start (simple)\n\nHere, we use the a droplet-based retina dataset from Macosko et al. (2015), provided in the `scRNAseq` package. This starts from a count matrix and finishes with clusters in preparation for biological interpretation. We also demonstrate how to identify differentially expressed genes between the clusters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(scRNAseq)\nsce <- MacoskoRetinaData()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nsee ?scRNAseq and browseVignettes('scRNAseq') for documentation\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nloading from cache\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nsee ?scRNAseq and browseVignettes('scRNAseq') for documentation\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nloading from cache\n```\n:::\n\n```{.r .cell-code}\n# Quality control (using mitochondrial genes).\nlibrary(scater)\nis.mito <- grepl(\"^MT-\", rownames(sce))\nqcstats <- perCellQCMetrics(sce, subsets=list(Mito=is.mito))\nfiltered <- quickPerCellQC(qcstats, percent_subsets=\"subsets_Mito_percent\")\nsce <- sce[, !filtered$discard]\n\n# Normalization.\nsce <- logNormCounts(sce)\n\n# Feature selection.\nlibrary(scran)\ndec <- modelGeneVar(sce)\nhvg <- getTopHVGs(dec, prop=0.1)\n\n# PCA.\nlibrary(scater)\nset.seed(1234)\nsce <- runPCA(sce, ncomponents=25, subset_row=hvg)\n\n# Clustering.\nlibrary(bluster)\ncolLabels(sce) <- clusterCells(sce, use.dimred='PCA',\n    BLUSPARAM=NNGraphParam(cluster.fun=\"louvain\"))    \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visualization.\nsce <- runUMAP(sce, dimred = 'PCA')\nplotUMAP(sce, colour_by=\"label\")\n```\n\n::: {.cell-output-display}\n![UMAP plot of the retina dataset, where each point is a cell and is colored by the assigned cluster identity.](intro-to-single-cell_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Marker detection (between pairs of groups)\nmarkers <- findMarkers(sce, test.type=\"wilcox\", direction=\"up\", lfc=1)\nlength(markers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13\n```\n:::\n\n```{.r .cell-code}\nmarkers[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 24658 rows and 16 columns\n                    Top      p.value          FDR summary.AUC     AUC.2\n              <integer>    <numeric>    <numeric>   <numeric> <numeric>\nMEG3                  1  0.00000e+00  0.00000e+00    0.867306  0.857315\nTUBA1A                1  3.58784e-81  5.89793e-78    0.609195  0.479862\nSNHG11                1  0.00000e+00  0.00000e+00    0.737419  0.747343\nSYT1                  2 3.51850e-268 1.08449e-264    0.786614  0.454677\nCALM1                 2  0.00000e+00  0.00000e+00    0.812019  0.665619\n...                 ...          ...          ...         ...       ...\nVSIG1             24654            1            1           0         0\nGM16390           24655            1            1           0         0\nGM25207           24656            1            1           0         0\n1110059M19RIK     24657            1            1           0         0\nGM20861           24658            1            1           0         0\n                  AUC.3     AUC.4     AUC.5     AUC.6     AUC.7     AUC.8\n              <numeric> <numeric> <numeric> <numeric> <numeric> <numeric>\nMEG3          0.6814265  0.463403  0.806255  0.478814 0.1822596  0.888640\nTUBA1A        0.1162662  0.315768  0.422655  0.289249 0.4529957  0.541010\nSNHG11        0.0822847  0.562474  0.741261  0.703891 0.0228628  0.742098\nSYT1          0.5354274  0.317921  0.786614  0.307464 0.0591646  0.549534\nCALM1         0.1535742  0.370682  0.715928  0.425258 0.0105809  0.791806\n...                 ...       ...       ...       ...       ...       ...\nVSIG1                 0         0         0         0         0         0\nGM16390               0         0         0         0         0         0\nGM25207               0         0         0         0         0         0\n1110059M19RIK         0         0         0         0         0         0\nGM20861               0         0         0         0         0         0\n                  AUC.9     AUC.10    AUC.11    AUC.12    AUC.13\n              <numeric>  <numeric> <numeric> <numeric> <numeric>\nMEG3           0.850705 0.48570145  0.866916  0.873796  0.867306\nTUBA1A         0.509171 0.33506617  0.552997  0.566389  0.609195\nSNHG11         0.745361 0.74450392  0.737413  0.744927  0.737419\nSYT1           0.823158 0.39904104  0.575948  0.584176  0.633476\nCALM1          0.444978 0.00587859  0.749949  0.834002  0.812019\n...                 ...        ...       ...       ...       ...\nVSIG1                 0          0         0         0         0\nGM16390               0          0         0         0         0\nGM25207               0          0         0         0         0\n1110059M19RIK         0          0         0         0         0\nGM20861               0          0         0         0         0\n```\n:::\n:::\n\n\n### Quick start (multiple batches)\n\nIf you could like to see Quick Start for scRNA-seq data with multiple batches, check out this workflow:\n\n-   https://bioconductor.org/books/3.15/OSCA.intro/analysis-overview.html#quick-start-multiple-batches\n\n## Session Info\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.1 (2023-06-16)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Sonoma 14.0\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: America/New_York\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] bluster_1.10.0              scran_1.28.2               \n [3] scRNAseq_2.14.0             scater_1.28.0              \n [5] ggplot2_3.4.4               scuttle_1.9.4              \n [7] SingleCellExperiment_1.22.0 SummarizedExperiment_1.30.2\n [9] Biobase_2.60.0              GenomicRanges_1.52.1       \n[11] GenomeInfoDb_1.36.4         IRanges_2.34.1             \n[13] S4Vectors_0.38.2            BiocGenerics_0.46.0        \n[15] MatrixGenerics_1.12.3       matrixStats_1.0.0          \n\nloaded via a namespace (and not attached):\n  [1] rstudioapi_0.15.0             jsonlite_1.8.7               \n  [3] magrittr_2.0.3                ggbeeswarm_0.7.2             \n  [5] GenomicFeatures_1.52.2        farver_2.1.1                 \n  [7] rmarkdown_2.25                BiocIO_1.10.0                \n  [9] zlibbioc_1.46.0               vctrs_0.6.4                  \n [11] memoise_2.0.1                 Rsamtools_2.16.0             \n [13] DelayedMatrixStats_1.22.6     RCurl_1.98-1.12              \n [15] htmltools_0.5.6.1             S4Arrays_1.0.6               \n [17] progress_1.2.2                AnnotationHub_3.8.0          \n [19] curl_5.1.0                    BiocNeighbors_1.18.0         \n [21] htmlwidgets_1.6.2             cachem_1.0.8                 \n [23] GenomicAlignments_1.36.0      igraph_1.5.1                 \n [25] mime_0.12                     lifecycle_1.0.3              \n [27] pkgconfig_2.0.3               rsvd_1.0.5                   \n [29] Matrix_1.6-1.1                R6_2.5.1                     \n [31] fastmap_1.1.1                 GenomeInfoDbData_1.2.10      \n [33] shiny_1.7.5.1                 digest_0.6.33                \n [35] colorspace_2.1-0              AnnotationDbi_1.62.2         \n [37] dqrng_0.3.1                   irlba_2.3.5.1                \n [39] ExperimentHub_2.8.1           RSQLite_2.3.1                \n [41] beachmat_2.16.0               labeling_0.4.3               \n [43] filelock_1.0.2                fansi_1.0.5                  \n [45] httr_1.4.7                    abind_1.4-5                  \n [47] compiler_4.3.1                bit64_4.0.5                  \n [49] withr_2.5.2                   BiocParallel_1.34.2          \n [51] viridis_0.6.4                 DBI_1.1.3                    \n [53] biomaRt_2.56.1                rappdirs_0.3.3               \n [55] DelayedArray_0.26.7           rjson_0.2.21                 \n [57] tools_4.3.1                   vipor_0.4.5                  \n [59] beeswarm_0.4.0                interactiveDisplayBase_1.38.0\n [61] httpuv_1.6.12                 glue_1.6.2                   \n [63] restfulr_0.0.15               promises_1.2.1               \n [65] grid_4.3.1                    cluster_2.1.4                \n [67] generics_0.1.3                gtable_0.3.4                 \n [69] ensembldb_2.24.1              hms_1.1.3                    \n [71] metapod_1.7.0                 BiocSingular_1.16.0          \n [73] ScaledMatrix_1.8.1            xml2_1.3.5                   \n [75] utf8_1.2.4                    XVector_0.40.0               \n [77] RcppAnnoy_0.0.21              ggrepel_0.9.4                \n [79] BiocVersion_3.17.1            pillar_1.9.0                 \n [81] stringr_1.5.0                 limma_3.56.2                 \n [83] later_1.3.1                   dplyr_1.1.3                  \n [85] BiocFileCache_2.8.0           lattice_0.22-5               \n [87] rtracklayer_1.60.1            bit_4.0.5                    \n [89] tidyselect_1.2.0              locfit_1.5-9.8               \n [91] Biostrings_2.68.1             knitr_1.44                   \n [93] gridExtra_2.3                 ProtGenerics_1.32.0          \n [95] edgeR_3.42.4                  xfun_0.40                    \n [97] statmod_1.5.0                 stringi_1.7.12               \n [99] lazyeval_0.2.2                yaml_2.3.7                   \n[101] evaluate_0.22                 codetools_0.2-19             \n[103] tibble_3.2.1                  BiocManager_1.30.22          \n[105] cli_3.6.1                     uwot_0.1.16                  \n[107] xtable_1.8-4                  munsell_0.5.0                \n[109] Rcpp_1.0.11                   dbplyr_2.3.4                 \n[111] png_0.1-8                     XML_3.99-0.15                \n[113] parallel_4.3.1                ellipsis_0.3.2               \n[115] blob_1.2.4                    prettyunits_1.2.0            \n[117] AnnotationFilter_1.24.0       sparseMatrixStats_1.12.2     \n[119] bitops_1.0-7                  viridisLite_0.4.2            \n[121] scales_1.2.1                  purrr_1.0.2                  \n[123] crayon_1.5.2                  rlang_1.1.1                  \n[125] KEGGREST_1.40.1              \n```\n:::\n:::\n",
    "supporting": [
      "intro-to-single-cell_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}